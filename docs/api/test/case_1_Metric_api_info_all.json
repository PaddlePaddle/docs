{"123": {"all_names": ["paddle.metric.Metric"], "id": 123, "type": "function", "docstring": "\n    Base class for metric, encapsulates metric logic and APIs\n    Usage:\n\n        .. code-block:: text\n\n            m = SomeMetric()\n            for prediction, label in ...:\n                m.update(prediction, label)\n            m.accumulate()\n\n    Advanced usage for :code:`compute`:\n\n    Metric calculation can be accelerated by calculating metric states\n    from model outputs and labels by build-in operators not by Python/NumPy\n    in :code:`compute`, metric states will be fetched as NumPy array and\n    call :code:`update` with states in NumPy format.\n    Metric calculated as follows (operations in Model and Metric are\n    indicated with curly brackets, while data nodes not):\n\n        .. code-block:: text\n\n                 inputs & labels              || ------------------\n                       |                      ||\n                    {model}                   ||\n                       |                      ||\n                outputs & labels              ||\n                       |                      ||    tensor data\n                {Metric.compute}              ||\n                       |                      ||\n              metric states(tensor)           ||\n                       |                      ||\n                {fetch as numpy}              || ------------------\n                       |                      ||\n              metric states(numpy)            ||    numpy data\n                       |                      ||\n                {Metric.update}               \\/ ------------------\n\n    Examples:\n\n        For :code:`Accuracy` metric, which takes :code:`pred` and :code:`label`\n        as inputs, we can calculate the correct prediction matrix between\n        :code:`pred` and :code:`label` in :code:`compute`.\n        For examples, prediction results contains 10 classes, while :code:`pred`\n        shape is [N, 10], :code:`label` shape is [N, 1], N is mini-batch size,\n        and we only need to calculate accurary of top-1 and top-5, we could\n        calculate the correct prediction matrix of the top-5 scores of the\n        prediction of each sample like follows, while the correct prediction\n        matrix shape is [N, 5].\n\n          .. code-block:: python\n            :name: code-compute-example\n\n              def compute(pred, label):\n                  # sort prediction and slice the top-5 scores\n                  pred = paddle.argsort(pred, descending=True)[:, :5]\n                  # calculate whether the predictions are correct\n                  correct = pred == label\n                  return paddle.cast(correct, dtype='float32')\n\n        With the :code:`compute`, we split some calculations to OPs (which\n        may run on GPU devices, will be faster), and only fetch 1 tensor with\n        shape as [N, 5] instead of 2 tensors with shapes as [N, 10] and [N, 1].\n        :code:`update` can be define as follows:\n\n          .. code-block:: python\n            :name: code-update-example\n\n              def update(self, correct):\n                  accs = []\n                  for i, k in enumerate(self.topk):\n                      num_corrects = correct[:, :k].sum()\n                      num_samples = len(correct)\n                      accs.append(float(num_corrects) / num_samples)\n                      self.total[i] += num_corrects\n                      self.count[i] += num_samples\n                  return accs\n    "}}